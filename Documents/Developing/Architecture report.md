# Архитектура To be  

Тип приложения: веб-приложение.  

Используемые языки: python, js, css, html  

Используемый фреймворк: django.     

Тип архитектуры: клиент-сервер.  

Причина выбора: всем пользователям нужен доступ к одним и тем же данным с разных устройств.  

Стратегия развёртывания: нужно распределённое развёртывание, так как фронтэнд-сервер, база данных и бэкэнд-серверы будут находиться на разных устройствах (серверах).  

Выбор технологии: библиотеки языка python позволяют работать с нейронными сетями и проводить быстрые вычисления, которые нужны для формирования списка рекомендаций пользователям. Языки js, css, html дают возможность написать шаблоны веб-страниц (возможность реализации пользовательского интерфейса).  

## Показатели качества  

### 1 Требования к доступности
**Объяснение** Приложение должно стремиться к минимальному времени простоя. 
**Обоснование** Чем больше время простоя, тем меньше рекомендаций можно показать. Чем меньше рекомендаций, тем меньше прибыль. 
**Возможный способ измерения** Сэмулировать реальные нагрузки на этапе тестирования и дать группе QA инженеров возможность пользоваться приложением несколько дней. 

### 2 Требования к масштабируемости
**Объяснение** Приложение может горизонтально масштабироваться. 
**Обоснование** Приложение вероятно столкнётся с большим количеством пользователей. Возможность масштабироваться является необходимым условием, чтобы предоставить обслуживание максимальному числу пользователей, что даст максимальную прибыль. 
**Возможный способ измерения** Увеличить количество серверов, обслуживающих приложение, провести тесты производительности 

### 3 Требования к удобству использования
3.1 **Объяснение** Количество элементов графического интерфейса должно стремиться к минимуму   
**Обоснование** Чем меньше элементов интерфейса, тем меньше усилий нужно приложить пользователю, чтобы выполнить нужную ему функцию, тем удобнее будет пользоваться приложением. С другой стороны, если не следовать данному требованию, то приложение будет проигрывать конкуренцию более удобным аналогам.   
**Возможный способ измерения** Поставить задачу QA инженерам найти лишние элементы интерфейса.   
3.2 **Объяснение** Количество действий для выполнения функции должно стремиться к минимуму   
**Обоснование** Аналогично предыдущему требованию.   
**Возможный способ измерения** Поставить задачу QA инженерам посчитать количество действий, необходимых для выполнения функций, чтобы найти далее те места, где можно и стоит уменьшить это количество.   
3.3 **Объяснение** Время реакции для всех необходимых операций должно стремиться к минимум  у 
**Обоснование** Аналогично предыдущему требованию.   
**Возможный способ измерения** Поставить задачу QA инженерам посчитать среднее время отклика при выполнении операций.   
3.4 **Объяснение** Приложение должно отображать обоснование для каждой рекомендации.   
**Обоснование** Вероятность появления доверия у пользователей к Wannait зависит от обоснования рекомендаций. Данная вероятность больше, если обоснование присутствует.   
**Возможный способ измерения** Поставить задачу QA инженерам проверить, что рядом с каждым продуктом выводится обоснование рекомендации.   
3.5 **Объяснение** Приложение должно уведомлять пользователя об успешной аутентификации.   
**Обоснование** Иначе пользователь может оказаться в ситуации, когда не понятно, зашёл ли он в учётную запись успешно или нет. Если у пользователя несколько учётных записей, то без данного требования выяснять, в какой конкретно сейчас он сидит, будет проблематично. 
**Возможный способ измерения** Поставить задачу QA инженерам проверить, после успешной аутенфикации на большинстве страниц выводится надпись "В настоящее время Вы зашли как ...".   

### 4 Требования к расширяемости  
**Объяснение** Спектр продуктов, предлагаемых приложением, можно расширить. Например, добавить рекомендацию книг, манги, аниме, игр.   
**Обоснование** Чем больше разных видов продуктов приложение может рекомендовать, тем больше количество обслуживаемых пользователей, тем больше прибыль. С другой стороны, выполнение требования позволит приложению адаптироваться к рынку.   
**Возможный способ измерения** Попробовать добавить новый тип продуктов и оценить результаты. 

### 5 Требования к безопасности
5.1 **Объяснение** Только владелец или администратор может изменять данные, связанные с продуктами владельца.   
**Обоснование** Без этого будет нарушаться закон об авторском праве   
**Возможный способ измерения** Поставить задачу сотрудникам ИБ найти способы изменить данные, связанные с продуктами, которые им не принадлежат.   
5.2 **Объяснение** Только владелец учётной записи может ей пользоваться.   
**Обоснование** Невыполнение требования вероятно уменьшит доверие к ресурсу, будет нарушать принцип конфиденциальности, закон об авторском праве и смежных правах.   
**Возможный способ измерения** Аналогично предыдущему требованию 

### 6 Требования к надёжности
**Объяснение** Данные о пользователях можно восстанавливать после сбоев   
**Обоснование** Необходимое условие для годных рекомендаций - наличие данных о пользователях. Нет выполнения условия - нет годных рекомендаций. Нет годных рекомендаций - нет дохода.   
**Возможный способ измерения** Поставить задачу сотрудникам ИБ попробовать привести приложение в состояние отказа, поставить задачу QA инженерам проверить возможность восстановления.  

## Пути реализации сквозной функциональности  

### 

![Architecture To be](https://github.com/L1ttl3S1st3r/wannait/blob/master/Documents/Design/ComponentsAndDeployment/components.jpg)

# Архитектура As is  

![Architecture As is](https://github.com/L1ttl3S1st3r/wannait/blob/master/Documents/Design/ComponentsAndDeployment/components.jpg)
![Class diagram](https://github.com/L1ttl3S1st3r/wannait/blob/master/Documents/Design/Class/classes.jpeg)

# Сравнение

Both architectures don't have any differencies, because previous developer (our Product Owner) made application how it needs to be. We can do one thing: check and fix dependencies between backend servers and database.

# Возможные улучшения

We can add several frontend servers (not only one), each of them would work with several backend servers, to decrease overload on each frontend server. It would be useful if many consumers would use this application at the same time.
